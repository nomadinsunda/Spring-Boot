# 🔍 `@Conditional`은 컴포넌트 스캔 대상 필터에 어떻게 작동하는가?

> "Spring은 클래스에 `@Conditional`이 붙어 있을 때,
> 아예 **BeanDefinition을 등록조차 하지 않을 수도** 있다.
> 그 판단은 어떻게 이루어질까?"

---

## ✅ 1. 기본 개념: `@Conditional`

```java
@Target({ TYPE, METHOD })
@Retention(RUNTIME)
@Documented
public @interface Conditional {
    Class<? extends Condition>[] value();
}
```

* 클래스나 메서드 수준에 붙일 수 있음
* `Condition` 인터페이스를 구현한 조건 클래스의 결과에 따라
  **해당 컴포넌트나 Bean 메서드를 무시할지 결정**

---

## ✅ 2. 어떤 시점에 작동하는가?

| 동작 위치                      | 처리 주체                            | 작동 시점       |
| -------------------------- | -------------------------------- | ----------- |
| @ComponentScan 대상 판단 시     | `ClassPathBeanDefinitionScanner` | 스캔 시        |
| @Configuration, @Bean 처리 시 | `ConfigurationClassParser`       | 설정 클래스 분석 시 |

> 즉, `@Conditional`은 **클래스가 BeanDefinition으로 등록되기 전에 필터링할 수 있습니다.**

---

## ✅ 3. ComponentScan에서 `@Conditional`은 어떻게 작동하는가?

### 📌 핵심 메서드: `ClassPathScanningCandidateComponentProvider#isCandidateComponent`

```java
public boolean isCandidateComponent(MetadataReader metadataReader) {
    return metadataReader.getAnnotationMetadata().isIndependent() &&
           isConditionMatch(metadataReader);
}
```

### 핵심: `isConditionMatch(...)` 내부 호출

```java
protected boolean isConditionMatch(MetadataReader metadataReader) {
    AnnotationMetadata metadata = metadataReader.getAnnotationMetadata();
    return conditionEvaluator.shouldInclude(metadata, ConfigurationPhase.REGISTER_BEAN);
}
```

### 결국 호출되는 핵심 로직: `Con성 파싱 시점                                                      |
| 대상    | `@Component`, `@Bean`, `@Configuration`, `@Import`, `@ImportResource` 등 |
| 내부 처리 | `ConditionEvaluator` → 모든 `Condition.matches()` 확인                      |
| 최종 목적 | 실행 환경에 따라 Bean 정의 자체를 유연하게 구성/제외                                        |
