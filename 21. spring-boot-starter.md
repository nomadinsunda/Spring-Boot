# 📦 `spring-boot-starter`란 무엇인가?

## ✅ 1. 스타터(Starter)의 개념

`spring-boot-starter-xxx`는 \*\*실제 로직을 포함하지 않는 "의존성 모음 패키지"\*\*입니다.
즉, Spring Boot 애플리케이션 개발자가 \*\*복잡한 의존성을 직접 나열하지 않아도 되도록 미리 패키징된 BOM(Bill of Materials)\*\*입니다.

> "Spring Boot에서 필요한 의존성들을 묶어서 제공하는 일종의 **편의용 선언적 의존성 패키지**"

---

## 🧱 2. 예시: `spring-boot-starter-web`

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

이 스타터는 다음과 같은 의존성들을 **transitive하게 가져옵니다**:

| 포함된 의존성                                 | 설명                      |
| --------------------------------------- | ----------------------- |
| `spring-web`                            | Spring Web MVC 핵심       |
| `spring-webmvc`                         | DispatcherServlet 포함    |
| `spring-boot-starter`                   | 로깅, 공통 설정 등 기본 구성 포함    |
| `spring-boot-starter-logging`           | 기본 로깅 시스템 Logback       |
| `jackson-databind`                      | JSON 직렬화/역직렬화           |
| `tomcat-embed-core`                     | 내장 톰캣 서버                |
| `validation-api`, `hibernate-validator` | JSR-380 Bean Validation |

---

## 🧩 3. 핵심: 스타터는 자동 구성을 유발하지 않는다?

맞습니다. 다음과 같이 정리됩니다:

| 대상                          | 자동 구성 유발 여부 | 설명                                                 |
| --------------------------- | ----------- | -------------------------------------------------- |
| `spring-boot-starter-web`   | ❌           | 자동 구성 클래스를 직접 포함하지 않음                              |
| `spring-boot-autoconfigure` | ✅           | 실제 자동 구성 클래스 포함 (`@Configuration`, `@Conditional`) |
| `spring-boot-starter-*`     | ❌           | 필요한 라이브러리를 묶어서 import 할 뿐                          |

### 왜 그럴까요?

스타터는 **선택된 기술 스택에 따라 자동 구성이 가능하도록 라이브러리를 classpath에 위치시키는 역할**만 수행합니다.

---

## ⚙️ 4. 자동 구성은 어떻게 연결되는가?

예시: `spring-boot-starter-web`을 추가하면…

→ 내부적으로 `spring-boot-autoconfigure`도 함께 추가됨
→ 이 안에 포함된 `WebMvcAutoConfiguration`이 classpath에 로딩됨
→ `AutoConfigurationImportSelector`가 이 클래스를 candidate로 인식
→ `@ConditionalOnClass(WebMvcConfigurer.class)` 조건 충족
→ 자동으로 DispatcherServlet, ViewResolver, MessageConverter 등 구성

---

## 🧠 5. 실제 구조 살펴보기 (`spring-boot-starter-web.pom`)

### 주요 POM

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <version>3.2.5</version>
  <type>pom</type>
</dependency>
```

### 내부 구조 (transitive dependencies)

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-json</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-tomcat</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-web</artifactId>
    </dependency>
    ...
</dependencies>
```

---

## 🔁 스타터 → classpath → 자동 구성 연결 흐름도

```text
spring-boot-starter-web
   ↓ (pom import)
spring-web, jackson, tomcat-embed-core
   ↓
classpath에 기술 스택 관련 라이브러리 존재
   ↓
@EnableAutoConfiguration
   ↓
AutoConfigurationImportSelector
   ↓
조건부로 WebMvcAutoConfiguration 등록
   ↓
DispatcherServlet 등 자동 등록
```

---

## ✅ 정리

| 항목                      | 설명                                                              |
| ----------------------- | --------------------------------------------------------------- |
| `spring-boot-starter-*` | 기술 스택에 필요한 라이브러리를 묶은 선언용 POM                                    |
| 자동 구성과의 관계              | 스타터 자체는 구성 클래스를 가지지 않음. 단지 구성 조건을 만족시키기 위한 라이브러리를 classpath에 넣음 |
| 자동 구성을 유발하는 주체          | `spring-boot-autoconfigure` 안의 `@Configuration` 클래스들            |
| 사용 효과                   | 개발자가 복잡한 의존성을 직접 나열하지 않고 빠르게 개발 가능                              |

---

## 📌 결론

> `spring-boot-starter-*`는 **직접 자동 구성을 수행하지 않습니다.**
> 단지 **자동 구성 조건이 충족되도록 classpath를 설정**해주는 역할입니다.
> \*\*자동 구성의 본체는 `spring-boot-autoconfigure.jar`\*\*입니다.

---

# 🧰 Spring Boot Starter 완전 정복

## 🟩 1. Starter란 무엇인가?

### 📌 정의

`Spring Boot Starter`는 특정 기능에 필요한 \*\*의존성들을 미리 패키징한 의존성 집합(POM)\*\*입니다. 즉, 당신이 **Web, JPA, Security, Redis** 등을 사용할 때 필요한 여러 라이브러리를 하나의 이름으로 선언할 수 있게 해줍니다.

### 🎯 목표

> **"개발자가 기술 스택에 맞는 라이브러리를 일일이 지정하지 않아도 되도록 단순화하고 표준화한 선언용 모듈"**

---

## 🧱 2. spring-boot-starter의 기본 구조

Spring Boot의 스타터는 모두 **다음과 같은 naming 규칙을 따릅니다:**

```
spring-boot-starter-<기능>
```

| 스타터 이름                         | 기능                                 |
| ------------------------------ | ---------------------------------- |
| `spring-boot-starter-web`      | 웹 개발 (Spring MVC, Jackson, Tomcat) |
| `spring-boot-starter-data-jpa` | JPA 및 Hibernate                    |
| `spring-boot-starter-security` | Spring Security                    |
| `spring-boot-starter-test`     | 테스트 관련 라이브러리 (JUnit, Mockito 등)    |
| `spring-boot-starter-actuator` | 모니터링 및 헬스체크                        |

---

## 🔍 3. 실제 내부 구성 분석

### ✅ 예시: `spring-boot-starter-web`

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

이 스타터는 다음과 같은 의존성을 transitive하게 포함합니다:

| 포함된 라이브러리                     | 설명           |
| ----------------------------- | ------------ |
| `spring-boot-starter`         | 기본 공통 스타터    |
| `spring-boot-starter-logging` | 로깅 (Logback) |
| `spring-web`, `spring-webmvc` | Spring MVC   |
| `jackson-databind`            | JSON 처리      |
| `tomcat-embed-core`           | 내장 톰캣        |

→ 하나만 선언하면 Spring Web 프로젝트 구성이 완성됩니다.

---

## 🧩 4. `spring-boot-starter`는 어떻게 구성되어 있나?

### ✅ `spring-boot-starter` 자체는 코드가 없음!

해당 모듈은 `pom.xml`만 존재하는 **POM 패키지**입니다.

```xml
<project>
  <artifactId>spring-boot-starter-web</artifactId>
  <packaging>pom</packaging>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
    </dependency>
    ...
  </dependencies>
</project>
```

이것이 의미하는 바는?

> ❗ **starter는 실제 기능을 제공하는 모듈이 아닌, 단지 의존성 번들임**

---

## ⚙️ 5. 자동 구성은 어떻게 연결되는가?

Starter 자체에는 `@Configuration`이 없습니다.
하지만 starter가 가져오는 라이브러리 중 **자동 구성 대상**이 존재합니다.

예시:

### `spring-boot-starter-data-jpa`가 가져오는 것들

| 포함 모듈                       | 자동 구성 대상 여부 |
| --------------------------- | ----------- |
| `spring-data-jpa`           | ✅           |
| `hibernate-core`            | ✅           |
| `spring-boot-autoconfigure` | ✅ ← 핵심      |

`spring-boot-autoconfigure.jar`에는 다음과 같은 구성 클래스가 있습니다:

```java
@Configuration
@ConditionalOnClass(EntityManager.class)
public class HibernateJpaAutoConfiguration {
}
```

→ classpath에 `EntityManager`가 있으니 자동 구성 실행!

---

## 🧠 6. 스타터 vs 자동 구성 비교

| 항목    | Starter           | Auto-Configuration         |
| ----- | ----------------- | -------------------------- |
| 역할    | 필요한 라이브러리를 번들로 제공 | 실제 동작하는 Bean 구성 정의         |
| 대상    | 개발자 편의를 위한 선언     | 프레임워크 내부 동작 제어             |
| 구성 방식 | POM 파일만 존재        | @Configuration 클래스 존재      |
| 실행 조건 | classpath에 있음     | 조건(@ConditionalOnXxx) 충족 시 |

---

## 🧪 7. 실전 예시

### `spring-boot-starter-web`을 선언하면?

1. Jackson, Tomcat, Spring MVC 로딩됨
2. classpath 조건 충족 → `WebMvcAutoConfiguration` 실행
3. DispatcherServlet, ViewResolver, MessageConverter 자동 등록
4. 개발자는 아무 설정 없이 `@RestController`만 만들면 끝

---

## 🛠️ 8. 스타터 직접 만들기 (Custom Starter)

당신도 스타터를 만들 수 있습니다.

### 예: `my-company-starter-db`

* POM 모듈로 만들고 내부에 JDBC, HikariCP 등 의존성 추가
* 별도의 `spring.factories`로 자동 구성 클래스 등록

```xml
<project>
  <artifactId>my-company-starter-db</artifactId>
  <packaging>pom</packaging>
  <dependencies>
    <dependency>... hikari ...</dependency>
    <dependency>... jdbc ...</dependency>
  </dependencies>
</project>
```

---

## ✅ 정리

| 항목         | 설명                                         |
| ---------- | ------------------------------------------ |
| 정의         | 라이브러리를 기술별로 묶어 편리하게 사용할 수 있도록 만든 선언용 POM   |
| 구성         | 의존성만 포함, 코드 없음                             |
| 실제 Bean 구성 | `spring-boot-autoconfigure.jar`가 담당        |
| 자동 구성 연결   | classpath에 존재 → 조건(`@Conditional`) 충족 시 실행 |
| 커스텀화       | 누구나 자신만의 starter를 만들 수 있음                  |

--


# 🔍 Spring Boot Starter: 내부 구조와 역할 완전 분석

---

## 1️⃣ Starter의 본질: 왜 필요한가?

### ✅ 기존 Spring 프로젝트의 단점

* Spring에서는 필요한 라이브러리를 수동으로 조합해야 했습니다.

  * 예: 웹 프로젝트라면 `spring-webmvc`, `jackson`, `tomcat`, `logback` 등을 직접 명시해야 했습니다.
* 라이브러리 간 버전 충돌, 설정 누락, 종속성 간 호환성 문제 발생

### 🎯 Spring Boot의 해결 방식: Starter

> "기능 중심의 의존성 셋을 하나의 논리적 패키지로 정의하자."

즉, `spring-boot-starter-xxx`는 기술 스택 단위의 **구성 세트를 표준화한 선언용 POM**입니다.

---

## 2️⃣ Spring Boot Starter의 유형

| 구분     | 예시                                            | 설명                      |
| ------ | --------------------------------------------- | ----------------------- |
| 기능 기반  | `spring-boot-starter-web`, `starter-data-jpa` | 각종 기술 스택 제공             |
| 시스템 기반 | `starter-logging`, `starter-actuator`         | 로깅, 모니터링 등 시스템 통합       |
| 테스트 기반 | `starter-test`                                | 테스트 관련 라이브러리 제공         |
| 공통 스타터 | `spring-boot-starter`                         | 로그, 예외 처리 등 최소 구성 요소 포함 |

---

## 3️⃣ Starter의 내부 구조: 소스 분석

### ✅ spring-boot-starter-web 예제

```xml
<project>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
  <packaging>pom</packaging>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-json</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-webmvc</artifactId>
    </dependency>
    <dependency>
      <groupId>org.apache.tomcat.embed</groupId>
      <artifactId>tomcat-embed-core</artifactId>
    </dependency>
  </dependencies>
</project>
```

### 🚨 중요한 점:

Starter는 자체적인 코드나 설정 파일을 포함하지 않습니다.
→ **단지 다른 의존성들을 묶은 POM 선언일 뿐**

---

## 4️⃣ Starter의 역할: 자동 구성 트리거

### ❓ 자동 구성은 어디서 발생하나?

* 자동 구성은 Starter가 아니라 `spring-boot-autoconfigure` 라이브러리의 역할
* 하지만 Starter가 **조건 만족을 위한 라이브러리를 classpath에 위치시킴**

예:

* `spring-boot-starter-data-jpa` → `hibernate-core`, `javax.persistence.EntityManager` 포함
* `@ConditionalOnClass(EntityManager.class)` 충족 → `HibernateJpaAutoConfiguration` 실행

```java
@Configuration
@ConditionalOnClass({EntityManager.class, HibernateJpaVendorAdapter.class})
@EnableConfigurationProperties(JpaProperties.class)
public class HibernateJpaAutoConfiguration { ... }
```

### 흐름 요약:

```text
1. Starter를 추가하면
2. 의존성에 따라 관련 JAR들이 classpath에 추가되고
3. EnableAutoConfiguration → AutoConfigurationImportSelector → spring.factories
4. 조건(@Conditional) 충족 시 Bean 자동 등록
```

---

## 5️⃣ 스타터 + 자동 구성 흐름도

```text
+---------------------------+
| spring-boot-starter-web  |  ← 개발자가 선언
+---------------------------+
            |
            ▼
+---------------------------+
| spring-webmvc, tomcat 등 |  ← 실제 기술 스택 JAR
+---------------------------+
            |
            ▼
+------------------------------+
| 조건 충족 (@Conditional...) | ← 자동 구성 조건 만족
+------------------------------+
            |
            ▼
+--------------------------------------+
| WebMvcAutoConfiguration 실행         | ← DispatcherServlet 등 Bean 등록
+--------------------------------------+
```

---

## 6️⃣ 스타터와 BOM (`spring-boot-dependencies`)의 관계

Spring Boot는 의존성 관리도 같이 해줍니다. 그 중심이 `spring-boot-dependencies`입니다.

### `spring-boot-dependencies`

* Maven의 `<dependencyManagement>`로 동작
* 모든 starter에서 사용되는 버전 일관성 제공
* 사용자 정의 프로젝트에서는 버전 생략 가능

```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-dependencies</artifactId>
      <version>3.2.5</version>
      <type>pom</type>
      <scope>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```

---

## 7️⃣ 실제 프로젝트에서의 활용 효과

### ✅ 개발자가 할 일

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-data-jpa</artifactId>
</dependency>
```

→ Hibernate, JPA API, 자동 구성 다 포함
→ `@Entity`만 작성해도 DB 연동됨

### 🧠 개발자는 기술 스택을 **선택만** 하면 되고,

→ 내부 구성과 조건 판단, Bean 생성은 모두 Spring Boot가 자동 수행

---



## ✅ 마무리 정리

| 항목        | 설명                                                               |
| --------- | ---------------------------------------------------------------- |
| Starter란  | 의존성 번들(POM)로, 특정 기술을 쉽게 사용할 수 있도록 구성                             |
| 자체 기능 유무  | 없음. 코드는 없고 의존성만 제공                                               |
| 자동 구성 주체  | spring-boot-autoconfigure의 구성 클래스                                |
| 동작 방식     | classpath 조건 만족 → 자동 구성 실행                                       |
| 대표 스타터    | `web`, `data-jpa`, `security`, `test`, `actuator`, `thymeleaf` 등 |
| 의존성 충돌 해결 | `spring-boot-dependencies` BOM이 중앙에서 관리                          |
| 커스텀 가능성   | 회사 또는 팀만의 스타터 구성 가능                                              |

